#! /usr/bin/python3

# hexfix
#  Tom Trebisky  1-22-2022 2-18-2022
#
# clean up various unpleasant issues in the disassembly
# generated by objdump.
# As an incidental benefit, we get rid of some trailing whitespace.
#
# more importantly, we convert a bunch of constants that are
# displayed in decimal to good old hex.
#
# We look for a # followed by a digit or - sign
# interestingly we never see #0x
#

import re
import sys

# infile = "callan13.dis"

# *** OLD, no longer used
# Deal with: moveq #97,%d3
# split on #, then on ,
def process1 ( thing ) :
    print ( "Process1-in: " + thing )
    t = thing.split("#")
    tt = t[1].split(',')

    h = tt[0]
    ival = int(tt[0])

#    if ival < -9 or ival > 9 :
#        h = hex(ival)
#        # strip silly leading "-"
#        if h[0] == '-' :
#            h = h[1:]
    if ival > 9 :
        h = hex(ival)

    if ival < -9 :
        h = hex ( ival & 0xffff )

    #print ( tt[0] )
    #print ( h )

    rval = t[0] + "#" + h + "," + tt[1]
    #return t[0] + "#" + tt[0] + "," + tt[1]
    print ( "Process1-out: " + rval )
    return rval

def fixit ( dingus, itype ) :
    if dingus[0] != '#' :
        return dingus

    sval = re.sub ( r'^#', '', dingus )
    ival = int(sval)

    if ival > 9 :
        sval = hex(ival)

    # We don't want negatives to end up bloated with
    # excess ff to the left for things like ffffffea
    # so we check if the end of the instruction was
    # w or b and trim accordingly
    if ival < -9 :
        bigval = (ival + (1 << 32)) % (1 << 32)
        if itype == 'b' :
            bigval = bigval & 0xff
        if itype == 'w' :
            bigval = bigval & 0xffff
        sval = hex ( bigval )

    return '#' + sval

# Deal with: btst %d6,#101
# unpk %d4,%d2,#-32230
#
# Here is the new concept:
# split on ' ' to get btst or unpk on the left
# split the right part into however many parts
#  it has by splitting on commas.
# Loop through those, looking for leading #
# and fixing those.
# put it all back together

def process2 ( thing ) :
    #print ( "Process2-in: " + thing )
    t = thing.split(' ')
    tt = t[1].split(',')

    #print ( "Tail: ", t[0], itype )
    # should be w, b, or l
    itype = t[0][-1]

    # This was really slick until I decided that
    # I wanted to pass the w or b to fixit.
    # tt2 = map ( fixit, tt )

    # So we unroll our own map.
    tt2 = []
    for x in tt :
        tt2.append ( fixit ( x, itype ) )

    #sval = fixit ( tt[1] )
    #return t[0] + ",#" + sval

    rval =  t[0] + ' ' + ",".join(tt2)
    #print ( "Process2-out: " + rval )
    return rval

# When developing we return None
def debug ( l ) :
    #return None
    return l

def scan ( line ) :
    if line.startswith(";") :
        return debug ( line )

    # linkw had decimal constants, but we don't mind
    # in that case.  And they are at the end of the
    # line as in:  linkw %fp,#-4
    if "linkw" in line :
        return debug ( line )

    # We leave these alone also
    if "moveq" in line :
        return debug ( line )

    # this is typically trap #7 or some such
    if "trap" in line :
        return debug ( line )

    # Stuff in our comments can have a # so trim them off.
    trim_line = re.sub ( r' *;.*', '', line )

    # Python is happy either way.
    #if not ", [" in line :
    if "#" not in trim_line :
        return debug ( line )

    # to fall through here, we have a line with
    # an immediate value we want to examine

    # lines have 3 sections split up by tabs
    # the address, the hex, the disassembly
    # we only want to work on the last of these
    lt = trim_line.split('\t')
    if len(lt) != 3 :
        return debug ( line )

    # it turns out that every thing with a #constant is
    # followed by a comma, the only case with
    # an immediate at the end is linkw and we
    # already return with that.
    #x = re.search ( "#.*,", lt[2] )
    #if ( x != None ) :
    #    return None

    # The sun3 has turned up this:
    # btst %d6,#101, so we now need
    # to deal with the case where
    # the immediate follows the comma.
    # this is process2()

    #if ",#" in lt[2] :
    #    lt[2] = process2 ( lt[2] )
    #else :
    #    lt[2] = process2 ( lt[2] )

    # For debug/test
    #showit = False
    #if "#-" in line :
    #    showit = True

    #if showit:
    #    print ( "Before: ", line )
    lt[2] = process2 ( lt[2] )
    rv = "\t".join(lt)
    #if showit:
    #    print ( "After : ", rv )

    return rv

# The Callan disassembly had these, but
#   the sun3 does not
# This is to fix ridiculous long strings
# of leading zeros like the following:
#   movel %a1@(0000000000000032,%d2:l:8),%d0
#   movel %a0@(0000000000000000,%d7:l),%d0

def scan2 ( line ) :
    l1 = re.sub ( r'\(0+(\d)', '(\\1', line, 4 )
    l2 = re.sub ( r'\(0+', '(', l1, 4 )
    return l2

if len(sys.argv) != 2 :
    print ( "usage: hexfix infile" )
    exit ()

infile = sys.argv[1]

with open ( infile ) as f:
    for raw in f:
        #line = raw.rstrip ()
        line = raw.strip ()
        #print ( "Line: " + line )
        fix1 = scan ( line )

        # in the production version,
        #  this is the only print we want
        print ( fix1 )

        # Callan needed this
        #fix2 = scan2 ( fix1 )
        #print ( fix2 )

# THE END
